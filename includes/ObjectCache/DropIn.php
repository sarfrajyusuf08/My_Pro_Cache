<?php
/**
 * Custom object cache drop-in backing Redis/Memcached for My Pro Cache.
 */
/**
 * My Pro Cache object cache engine.
 * Autogenerated â€“ do not edit directly.
 */

if ( ! defined( 'ABSPATH' ) ) {
    exit;
}

if ( ! defined( 'WP_CONTENT_DIR' ) ) {
    define( 'WP_CONTENT_DIR', dirname( __DIR__ ) );
}

$config = array();
if ( ! function_exists( 'trailingslashit' ) ) {
    function trailingslashit( string $value ): string {
        return rtrim( $value, '/\\' ) . '/';
    }
}

$config_file = WP_CONTENT_DIR . '/cache/my-pro-cache/object-cache-config.php';
if ( file_exists( $config_file ) ) {
    $config = include $config_file;
    if ( ! is_array( $config ) ) {
        $config = array();
    }
}

if ( ! class_exists( 'WP_Object_Cache', false ) ) {
    require_once ABSPATH . WPINC . '/class-wp-object-cache.php';
}

/**
 * Extends WP_Object_Cache to mirror data into external backends.
 */
class MyProCache_Object_Cache extends WP_Object_Cache {
    /** @var \Redis|\Memcached|null */
    protected $backend = null;

    protected string $backend_type = '';

    protected bool $compression = false;

    protected array $non_persistent_groups = array();
    protected array $persistent_groups = array();

    protected string $prefix = 'mpc:';

    public function __construct( array $config = array() ) {
        parent::__construct();

        $this->backend_type = isset( $config['backend'] ) ? strtolower( (string) $config['backend'] ) : 'redis';
        $this->compression  = ! empty( $config['compression'] );
        $this->persistent_groups = array_map( 'strval', $config['persistent_groups'] ?? array() );

        $this->connect_backend( $config );
    }

    /**
     * Track groups that should remain in memory only.
     */
    public function add_non_persistent_groups( $groups ) {
        $groups = (array) $groups;

        if ( method_exists( 'WP_Object_Cache', 'add_non_persistent_groups' ) ) {
            parent::add_non_persistent_groups( $groups );
        }

        foreach ( $groups as $group ) {
            if ( '' === $group ) {
                continue;
            }
            $this->non_persistent_groups[ $group ] = true;
        }
    }

    /**
     * Establish a connection to Redis or Memcached if available.
     */
    protected function connect_backend( array $config ): void {
        try {
            if ( 'memcached' === $this->backend_type && class_exists( '\Memcached', false ) ) {
                $client = new \Memcached();
                $client->addServer( $config['host'] ?? '127.0.0.1', (int) ( $config['port'] ?? 11211 ) );
                if ( ! empty( $config['compression'] ) ) {
                    $client->setOption( \Memcached::OPT_COMPRESSION, true );
                }
                $this->backend = $client;
            } elseif ( 'redis' === $this->backend_type && class_exists( '\Redis', false ) ) {
                $client = new \Redis();
                if ( ! empty( $config['port'] ) ) {
                    $client->connect( $config['host'] ?? '127.0.0.1', (int) $config['port'] );
                } else {
                    $client->connect( $config['host'] ?? '127.0.0.1' );
                }
                if ( ! empty( $config['auth'] ) ) {
                    $client->auth( $config['auth'] );
                }
                $this->backend = $client;
            }
        } catch ( \Throwable $e ) {
            $this->backend = null;
            error_log( '[My Pro Cache] Object cache backend connection failed: ' . $e->getMessage() );
        }
    }

    /**
     * Retrieve a value, falling back to the external backend when needed.
     */
    public function get( $key, $group = 'default', $force = false, &$found = null ) {
        $value = parent::get( $key, $group, $force, $found );

        if ( false === $found && $this->backend ) {
            $cache_key = $this->build_cache_key( $key, $group );
            $payload   = $this->backend_get( $cache_key );
            if ( null !== $payload ) {
                $found = true;
                $value = $payload;
                parent::set( $key, $value, $group );
            }
        }

        return $value;
    }

    /**
     * Store values in memory and mirror them into the backend.
     */
    public function set( $key, $data, $group = 'default', $expire = 0 ) {
        $result = parent::set( $key, $data, $group, $expire );

        if ( $result && $this->backend && $this->should_persist_group( $group ) ) {
            $cache_key = $this->build_cache_key( $key, $group );
            $this->backend_set( $cache_key, $data, (int) $expire );
        }

        return $result;
    }

    public function add( $key, $data, $group = 'default', $expire = 0 ) {
        if ( $this->get( $key, $group, false, $found ) ) {
            return false;
        }

        return $this->set( $key, $data, $group, $expire );
    }

    public function replace( $key, $data, $group = 'default', $expire = 0 ) {
        if ( ! $this->get( $key, $group, false, $found ) || ! $found ) {
            return false;
        }

        return $this->set( $key, $data, $group, $expire );
    }

    public function delete( $key, $group = 'default', $deprecated = false ) {
        $result = parent::delete( $key, $group, $deprecated );

        if ( $this->backend && $this->should_persist_group( $group ) ) {
            $cache_key = $this->build_cache_key( $key, $group );
            $this->backend_delete( $cache_key );
        }

        return $result;
    }

    public function incr( $key, $offset = 1, $group = 'default' ) {
        $value = parent::incr( $key, $offset, $group );

        if ( $value && $this->backend && $this->should_persist_group( $group ) ) {
            $cache_key = $this->build_cache_key( $key, $group );
            $this->backend_set( $cache_key, $value, 0 );
        }

        return $value;
    }

    public function decr( $key, $offset = 1, $group = 'default' ) {
        $value = parent::decr( $key, $offset, $group );

        if ( $value && $this->backend && $this->should_persist_group( $group ) ) {
            $cache_key = $this->build_cache_key( $key, $group );
            $this->backend_set( $cache_key, $value, 0 );
        }

        return $value;
    }

    public function flush(): bool {
        $result = parent::flush();

        if ( $this->backend ) {
            $this->backend_flush();
        }

        return $result;
    }

    /**
     * Write serialised payloads into the external backend.
     */
    protected function backend_set( string $key, $value, int $expire ): void {
        $payload = serialize( $value );

        if ( $this->compression && function_exists( 'gzcompress' ) ) {
            $payload = gzcompress( $payload );
        }

        try {
            if ( $this->backend instanceof \Redis ) {
                if ( $expire > 0 ) {
                    $this->backend->setex( $this->prefix . $key, $expire, $payload );
                } else {
                    $this->backend->set( $this->prefix . $key, $payload );
                }
            } elseif ( $this->backend instanceof \Memcached ) {
                $this->backend->set( $this->prefix . $key, $payload, $expire );
            }
        } catch ( \Throwable $e ) {
            error_log( '[My Pro Cache] Object cache write failed: ' . $e->getMessage() );
        }
    }

    /**
     * Fetch a cached payload from Redis or Memcached.
     */
    protected function backend_get( string $key ) {
        if ( ! $this->backend ) {
            return null;
        }

        try {
            if ( $this->backend instanceof \Redis ) {
                $payload = $this->backend->get( $this->prefix . $key );
            } elseif ( $this->backend instanceof \Memcached ) {
                $payload = $this->backend->get( $this->prefix . $key );
                if ( false === $payload && \Memcached::RES_NOTFOUND === $this->backend->getResultCode() ) {
                    return null;
                }
            } else {
                return null;
            }

            if ( false === $payload || null === $payload ) {
                return null;
            }

            if ( $this->compression && function_exists( 'gzuncompress' ) ) {
                $payload = @gzuncompress( $payload );
            }

            $value = @unserialize( $payload );
            if ( false === $value && 'b:0;' !== $payload ) {
                return null;
            }

            return $value;
        } catch ( \Throwable $e ) {
            error_log( '[My Pro Cache] Object cache read failed: ' . $e->getMessage() );
            return null;
        }
    }

    /**
     * Remove an entry from the external backend.
     */
    protected function backend_delete( string $key ): void {
        if ( $this->backend instanceof \Redis ) {
            $this->backend->del( $this->prefix . $key );
        } elseif ( $this->backend instanceof \Memcached ) {
            $this->backend->delete( $this->prefix . $key );
        }
    }

    /**
     * Flush all keys from the external backend.
     */
    protected function backend_flush(): void {
        if ( $this->backend instanceof \Redis ) {
            $this->backend->flushDB();
        } elseif ( $this->backend instanceof \Memcached ) {
            $this->backend->flush();
        }
    }

    /**
     * Determine whether a group should be mirrored externally.
     */
    protected function should_persist_group( string $group ): bool {
        if ( '' === $group ) {
            $group = 'default';
        }

        if ( empty( $this->persistent_groups ) ) {
            return true;
        }

        return in_array( $group, $this->persistent_groups, true );
    }
}

$GLOBALS['wp_object_cache'] = new MyProCache_Object_Cache( $config );

function wp_cache_add( $key, $data, $group = '', $expire = 0 ) {
    return $GLOBALS['wp_object_cache']->add( $key, $data, $group, (int) $expire );
}

function wp_cache_close(): bool {
    return true;
}

function wp_cache_decr( $key, $offset = 1, $group = '' ) {
    return $GLOBALS['wp_object_cache']->decr( $key, $offset, $group );
}

function wp_cache_delete( $key, $group = '' ) {
    return $GLOBALS['wp_object_cache']->delete( $key, $group );
}

function wp_cache_flush(): bool {
    return $GLOBALS['wp_object_cache']->flush();
}

function wp_cache_get( $key, $group = '', $force = false, &$found = null ) {
    return $GLOBALS['wp_object_cache']->get( $key, $group, $force, $found );
}

function wp_cache_incr( $key, $offset = 1, $group = '' ) {
    return $GLOBALS['wp_object_cache']->incr( $key, $offset, $group );
}

function wp_cache_init(): void {}

function wp_cache_replace( $key, $data, $group = '', $expire = 0 ) {
    return $GLOBALS['wp_object_cache']->replace( $key, $data, $group, (int) $expire );
}

function wp_cache_set( $key, $data, $group = '', $expire = 0 ) {
    return $GLOBALS['wp_object_cache']->set( $key, $data, $group, (int) $expire );
}

function wp_cache_add_global_groups( $groups ) {
    $GLOBALS['wp_object_cache']->add_global_groups( $groups );
}

function wp_cache_add_non_persistent_groups( $groups ) {
    $GLOBALS['wp_object_cache']->add_non_persistent_groups( $groups );
}

function wp_cache_switch_to_blog( $blog_id ) {
    return $GLOBALS['wp_object_cache']->switch_to_blog( $blog_id );
}

function wp_cache_reset() {
    $GLOBALS['wp_object_cache']->reset();
}

function wp_cache_supports( $feature ) {
    return method_exists( $GLOBALS['wp_object_cache'], $feature );
}
